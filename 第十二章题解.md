# cpp_primer

# C++ Promer习题解答

## 第十二章

### 12.1：
动态内存：
new 分配空间返回指向该对象的指针
delete 接受一个动态指针

智能指针：
负责自动释放所指的对象。都定义在memory头文件。
shared_ptr 允许多个指针指向同一个对象
unique_ptr 独占所指的对象
weak_ptr 弱引用，指向shared_ptr管理的对象

常用操作：
都支持的有：
shared_ptr<T> p1;
unique_ptr<T>p2; // 空智能指针，可以指向类型为T的对象
p // 将p作为一个条件判断，如果指向一个对象为true，如果是空指针为false
*p // 解引用指针取得对象
p->mem // 等价于(*p).mem
p.get() // 返回p中保存的指针（普通指针），要小心使用，若智能指针释放了对象，返回的指针所指向的对象也消失了
swap(p1,p2) // 交换p1和p2中的普通指针
p1.sawp(p2)

shared_ptr独有操作：
make_shared<T>(args) // 返回一个shared_ptr智能指针，指向一个动态分配的T类型的对象。使用args初始化此对象。入参agrs必须跟T的某个构造函数匹配。
shared_prt p(q) // 使用shared_ptr类型指针q初始化p,此操作会使q中的引用计数递增。

p = q; // p和q都是shared_ptr，此操作会递减p中的引用计数，递增q中的引用计数。若p中的引用计数为0，则将其管理的原内存释放。

p.unique() // 若p中的use_count为1则返回true，否则返回FALSE。
p.use_count() // 返回p中的引用计数，可能会比较慢，调试用。

还有：
shared_ptr<T> p(q) // 使用指向new分配的内置指针q初始化p
shared_ptr<T> p(u) // p从unique_ptr接管所有权，将u置空
shared_ptr<T> p(q,d) // 使用指向new分配的内置指针q初始化p，并使用d释放q
shared_ptr<T> p(q2, d) // q2是shared_ptr类型，p是q2的拷贝，使用d代替delete释放对象。
p.reset() // 如果p是唯一指向对象的shared_ptr，释放对象，p置为空
p.reset(q) // 如果p是唯一指向对象的shared_ptr，释放对象，p指向q， q是内置指针
p.reset(q, d) //  如果p是唯一指向对象的shared_ptr，释放对象，p指向q，并使用d代替delete


析构函数：
shared_ptr的析构函数会递减它所指向对象的引用计数。如果引用计数为0，shared_ptr的析构函数就会销毁对象，并释放它所占用的内存。

销毁对象：对于全局变量、静态变量程序声明周期结束销毁，同时回收内存。对于局部自动变量，随着函数调用结束，栈内存被回收。
对于动态创建的对象，需要主动销毁对象和释放内存。销毁对象是指该对象不可访问状态，此时内存空间并没有被回收。释放内存后才回收其内存空间。
析构函数就做的工作就是：递减引用计数，如果引用计数为0就销毁对象，并释放内存空间。


不要混用普通指针和只能指针：
当使用shared_ptr绑定到普通指针时，就将内存管理交给了shared_ptr，不可在用普通指针访问对象。
当使用p.get()获取普通指针时，不能使用delete释放普通指针，不能使用获取到的普通指针创建另一个shared_ptr。
p.reset(new int(1024)) 会递减p的引用计数，需要的话会释放p指向的对象，
if(!p.unique()){
    p.reset(new string(*p)); // 不是唯一的用户，分配新的拷贝
}
*p += newVal; // 是唯一的用户，可以放心改变p的值。


异常与释放：
使用智能指针在异常发生时仍能被释放。
使用普通指针在异常发生时不能被释放。
如果使用智能指针管理非new分配的内存，记得传递给他一个删除器。



unique_ptr:
unique_ptr<T> p;
unique_ptr<T> p(new T());
// unique_ptr<T> p(q); // q是内置指针，不支持赋值和拷贝
// p = q // 不支持赋值和拷贝

unique_ptr<T, D>p(d); // 使用类型为D的对象d代替delete
u = nullPtr; // 释放u指向的对象，将u置空

u.realese() // 切断u跟对象的联系，返回指向对象的普通指针
u.reset() // 释放u指向的对象
u.reset(p.release()) // 释放u指向的对象，并将u指向p
u.reset(nullptr) 










